/**
 * äº”å­æ£‹æ¸¸æˆä¸»é¡µé¢
 * å®ç°æ£‹ç›˜æ˜¾ç¤ºã€è½å­äº¤äº’ã€æ‚”æ£‹ã€èƒœè´Ÿåˆ¤å®šç­‰åŠŸèƒ½
 */

import { PieceType, GameStatus, GameConfig, DEFAULT_CONFIG, CONFIG_30X30, BOARD_SIZE_OPTIONS } from '../model/GameTypes';
import { GameState } from '../model/GameState';
import { hilog } from '@kit.PerformanceAnalysisKit';
import { media } from '@kit.MediaKit';

@Entry
@Component
struct Index {
  // æ¸¸æˆçŠ¶æ€ç®¡ç†
  private gameState: GameState = new GameState(DEFAULT_CONFIG);

  // ç‰ˆæœ¬ä¿¡æ¯
  private readonly appVersion: string = '1.0.0';
  private readonly author: string = 'é™ˆäº‘äº®';
  private readonly authorEmail: string = '676814828@qq.com';
  private readonly buildDate: string = '2024.12';

  // UIå“åº”å¼çŠ¶æ€
  @State boardData: PieceType[][] = [];
  @State currentPlayer: PieceType = PieceType.BLACK;
  @State gameStatus: GameStatus = GameStatus.PLAYING;
  @State lastMoveRow: number = -1;
  @State lastMoveCol: number = -1;
  @State totalMoves: number = 0;
  @State selectedBoardSize: number = 15; // å½“å‰é€‰ä¸­çš„æ£‹ç›˜å°ºå¯¸
  @State boardSize: number = 15;
  @State cellSize: number = 22;
  @State pieceSize: number = 20;
  @State isMaximized: boolean = false; // æœ€å¤§åŒ–æ¨¡å¼


  
  // ç¼©æ”¾ç›¸å…³çŠ¶æ€ï¼ˆæœ€å¤§åŒ–æ¨¡å¼ä½¿ç”¨ï¼‰
  @State scaleValue: number = 1; // å½“å‰ç¼©æ”¾æ¯”ä¾‹
  @State pinchValue: number = 1; // æåˆæ‰‹åŠ¿çš„ç¼©æ”¾å€¼
  @State minScale: number = 1.0; // æœ€å°ç¼©æ”¾
  @State maxScale: number = 2.0; // æœ€å¤§ç¼©æ”¾
  private baseCellSize30: number = 12; // 30è·¯æ£‹ç›˜åŸºç¡€æ ¼å­å¤§å°
  private basePieceSize30: number = 10; // 30è·¯æ£‹ç›˜åŸºç¡€æ£‹å­å¤§å°
  private defaultScale15: number = 2.0; // 15è·¯æœ€å¤§åŒ–é»˜è®¤ç¼©æ”¾ 200%
  private defaultScale30: number = 4.0; // 30è·¯æœ€å¤§åŒ–é»˜è®¤ç¼©æ”¾ 400%
  private minScale15: number = 1.0; // 15è·¯æœ€å°ç¼©æ”¾ 100%
  private maxScale15: number = 2.0; // 15è·¯æœ€å¤§ç¼©æ”¾ 200%
  private minScale30: number = 1.0; // 30è·¯æœ€å°ç¼©æ”¾ 100%
  private maxScale30: number = 4.0; // 30è·¯æœ€å¤§ç¼©æ”¾ 400%
  
  // æ‹–åŠ¨ç›¸å…³çŠ¶æ€ï¼ˆæœ€å¤§åŒ–æ¨¡å¼ä½¿ç”¨ï¼‰
  @State offsetX: number = 0; // æ°´å¹³åç§»
  @State offsetY: number = 0; // å‚ç›´åç§»
  private panOffsetX: number = 0; // æ‹–åŠ¨æ‰‹åŠ¿çš„æ°´å¹³åç§»
  private panOffsetY: number = 0; // æ‹–åŠ¨æ‰‹åŠ¿çš„å‚ç›´åç§»

  // æ£‹ç›˜é…ç½®
  private readonly boardPadding: number = 15; // æ£‹ç›˜è¾¹è·

  // æ˜Ÿä½åæ ‡é…ç½®
  private readonly starPoints15: number[][] = [
    [3, 3], [3, 7], [3, 11],
    [7, 3], [7, 7], [7, 11],
    [11, 3], [11, 7], [11, 11]
  ];

  // 30è·¯æ£‹ç›˜æ˜Ÿä½
  private readonly starPoints30: number[][] = [
    [3, 3], [3, 15], [3, 26],
    [15, 3], [15, 15], [15, 26],
    [26, 3], [26, 15], [26, 26]
  ];

  // éŸ³é¢‘æ’­æ”¾å™¨
  private blackPiecePlayer: media.AVPlayer | null = null;
  private whitePiecePlayer: media.AVPlayer | null = null;
  @State soundEnabled: boolean = true; // æ˜¯å¦å¯ç”¨å£°éŸ³

  aboutToAppear(): void {
    this.syncState();
    this.initAudioPlayers();
  }

  /**
   * åŒæ­¥æ¸¸æˆçŠ¶æ€åˆ°UI
   */
  private syncState(): void {
    this.boardData = this.gameState.getBoard();
    this.currentPlayer = this.gameState.getCurrentPlayer();
    this.gameStatus = this.gameState.getGameStatus();
    this.totalMoves = this.gameState.getTotalMoves();

    const lastMove = this.gameState.getLastMove();
    if (lastMove) {
      this.lastMoveRow = lastMove.row;
      this.lastMoveCol = lastMove.col;
    } else {
      this.lastMoveRow = -1;
      this.lastMoveCol = -1;
    }
  }

  /**
   * åˆå§‹åŒ–éŸ³é¢‘æ’­æ”¾å™¨
   */
  private async initAudioPlayers(): Promise<void> {
    try {
      // åˆ›å»ºé»‘å­éŸ³æ•ˆæ’­æ”¾å™¨
      this.blackPiecePlayer = await media.createAVPlayer();
      this.blackPiecePlayer.url = 'resource://rawfile/black_piece.mp3';
      
      // åˆ›å»ºç™½å­éŸ³æ•ˆæ’­æ”¾å™¨
      this.whitePiecePlayer = await media.createAVPlayer();
      this.whitePiecePlayer.url = 'resource://rawfile/white_piece.mp3';
      
      hilog.info(0x0000, 'GamePlay', 'Audio players initialized');
    } catch (error) {
      hilog.error(0x0000, 'GamePlay', `Failed to initialize audio players: ${error}`);
    }
  }

  /**
   * æ’­æ”¾è½å­éŸ³æ•ˆ
   */
  private playPieceSound(pieceType: PieceType): void {
    if (!this.soundEnabled) {
      return;
    }
    
    try {
      if (pieceType === PieceType.BLACK && this.blackPiecePlayer) {
        // é‡ç½®å¹¶æ’­æ”¾é»‘å­éŸ³æ•ˆ
        this.blackPiecePlayer.seek(0);
        this.blackPiecePlayer.play();
        hilog.info(0x0000, 'GamePlay', 'Playing black piece sound');
      } else if (pieceType === PieceType.WHITE && this.whitePiecePlayer) {
        // é‡ç½®å¹¶æ’­æ”¾ç™½å­éŸ³æ•ˆ
        this.whitePiecePlayer.seek(0);
        this.whitePiecePlayer.play();
        hilog.info(0x0000, 'GamePlay', 'Playing white piece sound');
      }
    } catch (error) {
      hilog.error(0x0000, 'GamePlay', `Failed to play sound: ${error}`);
    }
  }

  /**
   * å¤„ç†è½å­äº‹ä»¶
   */
  private handleCellClick(row: number, col: number): void {
    hilog.info(0x0000, 'GamePlay', `=== Cell clicked: row=${row}, col=${col} ===`);
    hilog.info(0x0000, 'GamePlay', `Current player: ${this.currentPlayer === PieceType.BLACK ? 'BLACK' : 'WHITE'}`);
    hilog.info(0x0000, 'GamePlay', `Game status: ${this.gameStatus}`);
    hilog.info(0x0000, 'GamePlay', `Total moves before: ${this.totalMoves}`);
    
    // ä¿å­˜å½“å‰ç©å®¶ï¼ˆè½å­å‰ï¼‰
    const currentPieceType = this.currentPlayer;
    
    if (this.gameState.placePiece(row, col)) {
      hilog.info(0x0000, 'GamePlay', `Piece placed successfully at (${row}, ${col})`);
      // æ’­æ”¾è½å­éŸ³æ•ˆ
      this.playPieceSound(currentPieceType);
      this.syncState();
      hilog.info(0x0000, 'GamePlay', `Total moves after: ${this.totalMoves}`);
      hilog.info(0x0000, 'GamePlay', `New game status: ${this.gameStatus}`);
    } else {
      hilog.warn(0x0000, 'GamePlay', `Failed to place piece at (${row}, ${col}) - position may be occupied or game is over`);
    }
  }

  /**
   * å¤„ç†æ‚”æ£‹äº‹ä»¶
   */
  private handleUndo(): void {
    hilog.info(0x0000, 'GamePlay', '=== Undo button clicked ===');
    hilog.info(0x0000, 'GamePlay', `Total moves before undo: ${this.totalMoves}`);
    
    if (this.gameState.undo()) {
      hilog.info(0x0000, 'GamePlay', 'Undo successful');
      this.syncState();
      hilog.info(0x0000, 'GamePlay', `Total moves after undo: ${this.totalMoves}`);
    } else {
      hilog.warn(0x0000, 'GamePlay', 'Undo failed - no moves to undo');
    }
  }

  /**
   * å¤„ç†é‡æ–°å¼€å§‹äº‹ä»¶
   */
  private handleRestart(): void {
    hilog.info(0x0000, 'GamePlay', '=== Restart button clicked ===');
    
    
    this.gameState.reset();
    this.syncState();
    hilog.info(0x0000, 'GamePlay', 'Game reset successfully');
  }

  /**
   * è·å–çŠ¶æ€æ–‡æœ¬
   */
  private getStatusText(): string {
    switch (this.gameStatus) {
      case GameStatus.BLACK_WIN:
        return 'é»‘æ–¹è·èƒœï¼';
      case GameStatus.WHITE_WIN:
        return 'ç™½æ–¹è·èƒœï¼';
      case GameStatus.DRAW:
        return 'å¹³å±€ï¼';
      default:
        return this.currentPlayer === PieceType.BLACK ? 'é»‘æ–¹å›åˆ' : 'ç™½æ–¹å›åˆ';
    }
  }

  /**
   * æ£€æŸ¥æ˜¯å¦ä¸ºæ˜Ÿä½
   */
  private isStarPoint(row: number, col: number): boolean {
    const starPoints = this.boardSize === 15 ? this.starPoints15 : this.starPoints30;
    for (const point of starPoints) {
      if (point[0] === row && point[1] === col) {
        return true;
      }
    }
    return false;
  }

  /**
   * åˆ‡æ¢æ£‹ç›˜å°ºå¯¸
   */
  private switchBoardSize(size: number): void {
    hilog.info(0x0000, 'GamePlay', `=== Switch board size clicked: ${size} ===`);
    
    if (size === this.boardSize) {
      hilog.info(0x0000, 'GamePlay', `Board size already ${size}, no change needed`);
      return;
    }
    
    this.selectedBoardSize = size;
    this.boardSize = size;
    this.isMaximized = false; // é‡ç½®æœ€å¤§åŒ–çŠ¶æ€
    hilog.info(0x0000, 'GamePlay', `Board size changed to: ${size}`);

    // æ ¹æ®æ£‹ç›˜å°ºå¯¸è°ƒæ•´æ ¼å­å’Œæ£‹å­å¤§å°
    if (size === 30) {
      this.cellSize = this.baseCellSize30;
      this.pieceSize = this.basePieceSize30;
      this.scaleValue = 1; // é‡ç½®ç¼©æ”¾
      this.pinchValue = 1;
      this.offsetX = 0; // é‡ç½®åç§»
      this.offsetY = 0;
      this.panOffsetX = 0;
      this.panOffsetY = 0;
      this.gameState = new GameState(CONFIG_30X30);
      hilog.info(0x0000, 'GamePlay', '30x30 board initialized with scaling support');
    } else {
      this.cellSize = 22;
      this.pieceSize = 20;
      this.scaleValue = 1;
      this.pinchValue = 1;
      this.offsetX = 0;
      this.offsetY = 0;
      this.panOffsetX = 0;
      this.panOffsetY = 0;
      this.gameState = new GameState(DEFAULT_CONFIG);
      hilog.info(0x0000, 'GamePlay', '15x15 board initialized');
    }

    this.syncState();
  }



  build() {
    Column() {
      // æ ‡é¢˜åŒºåŸŸï¼ˆéæœ€å¤§åŒ–æ¨¡å¼æ˜¾ç¤ºï¼‰
      if (!this.isMaximized) {
        Text('FiveInRow äº”å­æ£‹')
          .fontSize(28)
          .fontWeight(FontWeight.Bold)
          .fontColor($r('app.color.primary_text'))
          .margin({ top: 20, bottom: 10 })
      }



      // æ£‹ç›˜å°ºå¯¸é€‰æ‹©åŒºåŸŸï¼ˆéæœ€å¤§åŒ–æ¨¡å¼æ˜¾ç¤ºï¼‰
      if (!this.isMaximized) {
        Row() {
          Text('æ£‹ç›˜å°ºå¯¸:')
            .fontSize(14)
            .fontColor($r('app.color.secondary_text'))
            .margin({ right: 10 })

          Button('15Ã—15')
            .fontSize(14)
            .fontColor(this.selectedBoardSize === 15 ? $r('app.color.button_text') : $r('app.color.primary_text'))
            .backgroundColor(this.selectedBoardSize === 15 ? $r('app.color.button_primary') : '#E0E0E0')
            .width(80)
            .height(32)
            .borderRadius(16)
            .onClick(() => this.switchBoardSize(15))

          Button('30Ã—30')
            .fontSize(14)
            .fontColor(this.selectedBoardSize === 30 ? $r('app.color.button_text') : $r('app.color.primary_text'))
            .backgroundColor(this.selectedBoardSize === 30 ? $r('app.color.button_primary') : '#E0E0E0')
            .width(80)
            .height(32)
            .borderRadius(16)
            .margin({ left: 10 })
            .onClick(() => this.switchBoardSize(30))
        }
        .margin({ bottom: 5 })

        // æœ€å¤§åŒ–æŒ‰é’®å’Œå£°éŸ³å¼€å…³
        Row() {
          Button('æœ€å¤§åŒ–')
            .fontSize(14)
            .fontColor($r('app.color.button_text'))
            .backgroundColor('#FF6B35')
            .width(80)
            .height(32)
            .borderRadius(16)
            .onClick(() => this.toggleMaximize())

          Button(this.soundEnabled ? 'ğŸ”Š å£°éŸ³' : 'ğŸ”‡ é™éŸ³')
            .fontSize(14)
            .fontColor($r('app.color.button_text'))
            .backgroundColor(this.soundEnabled ? '#4CAF50' : '#9E9E9E')
            .width(80)
            .height(32)
            .borderRadius(16)
            .margin({ left: 10 })
            .onClick(() => {
              this.soundEnabled = !this.soundEnabled;
            })
        }
        .margin({ bottom: 10 })
      }



      // çŠ¶æ€æ˜¾ç¤ºåŒºåŸŸï¼ˆéæœ€å¤§åŒ–æ¨¡å¼æ˜¾ç¤ºå®Œæ•´ä¿¡æ¯ï¼‰
      if (!this.isMaximized) {
        Row() {
          // å½“å‰å›åˆæŒ‡ç¤ºå™¨
          if (this.gameStatus === GameStatus.PLAYING) {
            Circle({ width: 24, height: 24 })
              .fill(this.currentPlayer === PieceType.BLACK ?
                $r('app.color.black_turn_indicator') : $r('app.color.white_turn_indicator'))
              .stroke($r('app.color.board_line'))
              .strokeWidth(1)
              .margin({ right: 8 })
          }

          Text(this.getStatusText())
            .fontSize(20)
            .fontWeight(FontWeight.Medium)
            .fontColor(this.gameStatus !== GameStatus.PLAYING ?
              $r('app.color.win_color') : $r('app.color.primary_text'))
        }
        .margin({ bottom: 10 })

        // æ­¥æ•°æ˜¾ç¤º
        Text(`æ€»æ­¥æ•°: ${this.totalMoves}`)
          .fontSize(14)
          .fontColor($r('app.color.secondary_text'))
          .margin({ bottom: this.boardSize === 30 ? 5 : 15 })
      }
      
      // æœ€å¤§åŒ–æ¨¡å¼ï¼šç®€åŒ–çŠ¶æ€æ˜¾ç¤º
      if (this.isMaximized) {
        Row() {
          // ç¼©å°æŒ‰é’®
          Button('é€€å‡ºæœ€å¤§åŒ–')
            .fontSize(12)
            .fontColor($r('app.color.button_text'))
            .backgroundColor('#FF6B35')
            .height(28)
            .borderRadius(14)
            .margin({ right: 15 })
            .onClick(() => this.toggleMaximize())

          // å½“å‰å›åˆæŒ‡ç¤ºå™¨
          if (this.gameStatus === GameStatus.PLAYING) {
            Circle({ width: 20, height: 20 })
              .fill(this.currentPlayer === PieceType.BLACK ?
                $r('app.color.black_turn_indicator') : $r('app.color.white_turn_indicator'))
              .stroke($r('app.color.board_line'))
              .strokeWidth(1)
              .margin({ right: 6 })
          }

          Text(this.getStatusText())
            .fontSize(16)
            .fontWeight(FontWeight.Medium)
            .fontColor(this.gameStatus !== GameStatus.PLAYING ?
              $r('app.color.win_color') : $r('app.color.primary_text'))

          Text(` | ${(this.scaleValue * 100).toFixed(0)}%`)
            .fontSize(12)
            .fontColor($r('app.color.secondary_text'))
            .margin({ left: 10 })

          Text(' | åŒæŒ‡ç¼©æ”¾/ç§»åŠ¨')
            .fontSize(11)
            .fontColor('#888888')
            .margin({ left: 8 })
        }
        .margin({ top: 0, bottom: 0 })
      }
      
      // ç¼©æ”¾æç¤ºï¼ˆéæœ€å¤§åŒ–çš„30Ã—30æ£‹ç›˜ï¼‰
      if (!this.isMaximized && this.boardSize === 30) {
        Text(`åŒæŒ‡ç¼©æ”¾: ${(this.scaleValue * 100).toFixed(0)}% | æ”¯æŒåŒæŒ‡æ‹–æ‹½ç§»åŠ¨`)
          .fontSize(12)
          .fontColor($r('app.color.secondary_text'))
          .margin({ bottom: 10 })
      }

      // æ£‹ç›˜åŒºåŸŸ
      if (this.isMaximized || this.boardSize === 30) {
        // æœ€å¤§åŒ–æ¨¡å¼æˆ–30Ã—30æ£‹ç›˜ï¼šæ”¯æŒç¼©æ”¾å’Œæ‹–æ‹½
        Stack() {
          Column() {
            // ç»˜åˆ¶æ£‹ç›˜ç½‘æ ¼
            ForEach(this.getRowIndices(), (row: number) => {
              Row() {
                ForEach(this.getColIndices(), (col: number) => {
                  this.BoardCell(row, col)
                })
              }
            })
          }
          .backgroundColor($r('app.color.board_background'))
          .padding(this.boardPadding)
          .borderRadius(8)
          .shadow({
            radius: 10,
            color: '#33000000',
            offsetX: 2,
            offsetY: 4
          })
          .scale({ x: this.scaleValue, y: this.scaleValue })
          .translate({ x: this.offsetX, y: this.offsetY })
        }
        .width('100%')
        .height('100%')
        .clip(true)
        .gesture(
          GestureGroup(GestureMode.Parallel,
            // åŒæŒ‡ç¼©æ”¾æ‰‹åŠ¿ï¼ˆ15Ã—15å’Œ30Ã—30éƒ½æ”¯æŒç¼©æ”¾ï¼‰
            PinchGesture({ fingers: 2 })
              .onActionStart((event: GestureEvent) => {
                this.pinchValue = this.scaleValue;
              })
              .onActionUpdate((event: GestureEvent) => {
                if (event && event.scale) {
                  let newScale = this.pinchValue * event.scale;
                  // æ ¹æ®æ£‹ç›˜å°ºå¯¸ä½¿ç”¨ä¸åŒçš„ç¼©æ”¾é™åˆ¶
                  const minLimit = this.boardSize === 15 ? this.minScale15 : this.minScale30;
                  const maxLimit = this.boardSize === 15 ? this.maxScale15 : this.maxScale30;
                  newScale = Math.max(minLimit, Math.min(maxLimit, newScale));
                  this.scaleValue = newScale;
                }
              })
              .onActionEnd(() => {
                this.pinchValue = this.scaleValue;
              }),
            // åŒæŒ‡æ‹–åŠ¨æ‰‹åŠ¿
            PanGesture({ fingers: 2, direction: PanDirection.All })
              .onActionStart(() => {
                this.panOffsetX = this.offsetX;
                this.panOffsetY = this.offsetY;
              })
              .onActionUpdate((event: GestureEvent) => {
                if (event) {
                  this.offsetX = this.panOffsetX + (event.offsetX || 0);
                  this.offsetY = this.panOffsetY + (event.offsetY || 0);
                }
              })
              .onActionEnd(() => {
                this.panOffsetX = this.offsetX;
                this.panOffsetY = this.offsetY;
              })
          )
        )
        .layoutWeight(1)
        .margin({ bottom: this.isMaximized ? 0 : 10 })
      } else {
        // 15Ã—15æ£‹ç›˜éæœ€å¤§åŒ–ï¼šä¿æŒåŸæ ·
        Stack() {
          // æ£‹ç›˜èƒŒæ™¯
          Column() {
            // ç»˜åˆ¶æ£‹ç›˜ç½‘æ ¼
            ForEach(this.getRowIndices(), (row: number) => {
              Row() {
                ForEach(this.getColIndices(), (col: number) => {
                  this.BoardCell(row, col)
                })
              }
            })
          }
          .backgroundColor($r('app.color.board_background'))
          .padding(this.boardPadding)
          .borderRadius(8)
          .shadow({
            radius: 10,
            color: '#33000000',
            offsetX: 2,
            offsetY: 4
          })
        }
        .margin({ bottom: 20 })
      }

      // æ“ä½œæŒ‰é’®åŒºåŸŸ
      Row() {
        Button('æ‚”æ£‹')
          .fontSize(this.isMaximized ? 14 : 16)
          .fontColor($r('app.color.button_text'))
          .backgroundColor($r('app.color.button_secondary'))
          .width(this.isMaximized ? 80 : 100)
          .height(this.isMaximized ? 36 : 44)
          .borderRadius(this.isMaximized ? 18 : 22)
          .enabled(this.totalMoves > 0)
          .opacity(this.totalMoves > 0 ? 1 : 0.5)
          .onClick(() => this.handleUndo())

        Button('é‡æ–°å¼€å§‹')
          .fontSize(this.isMaximized ? 14 : 16)
          .fontColor($r('app.color.button_text'))
          .backgroundColor($r('app.color.button_primary'))
          .width(this.isMaximized ? 100 : 120)
          .height(this.isMaximized ? 36 : 44)
          .borderRadius(this.isMaximized ? 18 : 22)
          .margin({ left: 20 })
          .enabled(this.totalMoves > 0)
          .opacity(this.totalMoves > 0 ? 1 : 0.5)
          .onClick(() => this.handleRestart())
      }
      .margin({ bottom: this.isMaximized ? 0 : (this.boardSize === 30 ? 10 : 20) })

      // ç‰ˆæœ¬ä¿¡æ¯å’Œå…³äºä½œè€…ï¼ˆéæœ€å¤§åŒ–æ¨¡å¼æ˜¾ç¤ºï¼‰
      if (!this.isMaximized) {
        Column() {
          Text(`v${this.appVersion}`)
            .fontSize(12)
            .fontColor($r('app.color.secondary_text'))
            .margin({ bottom: 4 })

          Text(`ä½œè€…: ${this.author}`)
            .fontSize(11)
            .fontColor($r('app.color.secondary_text'))
            .margin({ bottom: 2 })

          Text(this.authorEmail)
            .fontSize(10)
            .fontColor($r('app.color.secondary_text'))
        }
        .margin({ bottom: this.boardSize === 30 ? 10 : 15 })
      }
    }
    .width('100%')
    .height('100%')
    .backgroundColor($r('app.color.page_background'))
    .justifyContent(FlexAlign.Start)
    .alignItems(HorizontalAlign.Center)
  }

  /**
   * åˆ‡æ¢æœ€å¤§åŒ–æ¨¡å¼
   */
  private toggleMaximize(): void {
    this.isMaximized = !this.isMaximized;
    hilog.info(0x0000, 'GamePlay', `Maximize mode: ${this.isMaximized}`);

    if (this.isMaximized) {
      // è¿›å…¥æœ€å¤§åŒ–æ¨¡å¼ï¼Œè®¾ç½®é»˜è®¤ç¼©æ”¾å’Œç¼©æ”¾é™åˆ¶
      if (this.boardSize === 15) {
        this.scaleValue = this.defaultScale15; // 15Ã—15 é»˜è®¤æ”¾å¤§200%
        this.minScale = this.minScale15;
        this.maxScale = this.maxScale15;
      } else {
        this.scaleValue = this.defaultScale30; // 30Ã—30 é»˜è®¤æ”¾å¤§300%
        this.minScale = this.minScale30;
        this.maxScale = this.maxScale30;
      }
      this.pinchValue = this.scaleValue;
      this.offsetX = 0;
      this.offsetY = 0;
      this.panOffsetX = 0;
      this.panOffsetY = 0;
    } else {
      // é€€å‡ºæœ€å¤§åŒ–æ¨¡å¼ï¼Œæ¢å¤é»˜è®¤ç¼©æ”¾
      this.scaleValue = 1;
      this.pinchValue = 1;
      this.offsetX = 0;
      this.offsetY = 0;
      this.panOffsetX = 0;
      this.panOffsetY = 0;
    }
  }

  /**
   * è·å–è¡Œç´¢å¼•æ•°ç»„
   */
  private getRowIndices(): number[] {
    const indices: number[] = [];
    for (let i = 0; i < this.boardSize; i++) {
      indices.push(i);
    }
    return indices;
  }

  /**
   * è·å–åˆ—ç´¢å¼•æ•°ç»„
   */
  private getColIndices(): number[] {
    const indices: number[] = [];
    for (let i = 0; i < this.boardSize; i++) {
      indices.push(i);
    }
    return indices;
  }

  /**
   * æ£‹ç›˜å•å…ƒæ ¼ç»„ä»¶
   */
  @Builder
  BoardCell(row: number, col: number) {
    Stack() {
      // ç»˜åˆ¶ç½‘æ ¼çº¿
      Canvas(new CanvasRenderingContext2D(new RenderingContextSettings(true)))
        .width(this.cellSize)
        .height(this.cellSize)
        .onReady(() => { })

      // ç½‘æ ¼çº¿èƒŒæ™¯
      Column() {
        // æ°´å¹³çº¿
        if (row > 0 || row < this.boardSize - 1) {
          Line()
            .width(col === 0 ? this.cellSize / 2 : (col === this.boardSize - 1 ? this.cellSize / 2 : this.cellSize))
            .height(1)
            .backgroundColor($r('app.color.board_line'))
            .position({
              x: col === 0 ? this.cellSize / 2 : 0,
              y: this.cellSize / 2
            })
        }
      }
      .width(this.cellSize)
      .height(this.cellSize)

      // å‚ç›´çº¿
      Column() {
        Line()
          .width(1)
          .height(row === 0 ? this.cellSize / 2 : (row === this.boardSize - 1 ? this.cellSize / 2 : this.cellSize))
          .backgroundColor($r('app.color.board_line'))
          .position({
            x: this.cellSize / 2,
            y: row === 0 ? this.cellSize / 2 : 0
          })
      }
      .width(this.cellSize)
      .height(this.cellSize)

      // æ˜Ÿä½
      if (this.isStarPoint(row, col)) {
        Circle({ width: this.boardSize === 30 ? 4 : 6, height: this.boardSize === 30 ? 4 : 6 })
          .fill($r('app.color.star_point'))
      }

      // æ£‹å­
      if (this.boardData.length > row && this.boardData[row].length > col) {
        if (this.boardData[row][col] !== PieceType.EMPTY) {
          // æ£‹å­æœ¬ä½“
          Circle({ width: this.pieceSize, height: this.pieceSize })
            .fill(this.boardData[row][col] === PieceType.BLACK ?
              $r('app.color.black_piece') : $r('app.color.white_piece'))
            .stroke(this.boardData[row][col] === PieceType.BLACK ? '#000000' : '#CCCCCC')
            .strokeWidth(0.5)
            .shadow({
              radius: 2,
              color: '#44000000',
              offsetX: 1,
              offsetY: 1
            })

          // æœ€åè½å­æ ‡è®°
          if (row === this.lastMoveRow && col === this.lastMoveCol) {
            Circle({ width: this.boardSize === 30 ? 4 : 6, height: this.boardSize === 30 ? 4 : 6 })
              .fill($r('app.color.last_move_marker'))
          }
        }
      }
    }
    .width(this.cellSize)
    .height(this.cellSize)
    .onClick(() => {
      this.handleCellClick(row, col);
    })
  }
}
